# Инструкция по работе с git

## Что это и для чего нужна система контроля версий?

### Что такое система контроля версий?

### Для чего нужна система контроля версий

## Установка git и VSCode на ваш ПК.

### Установка VSCode на ваш ПК.

### Установка git на ваш ПК

#### Первая настройка git

## Создание и базовая работа с локальным репозиторием.

Для того чтобы создать свой локальный репозиторий, необходимо выбрать необходимую директорию через команду ``cd`` "адрес директории", после чего ввести ``git init``, после чего все другие команды git (такие как ``add``, ``commit``, ``branch`` и т.д.) начнут опозноваться и выполняться. После можно спокойно работать с имеющимися файлами в репозитории (вашей папке) и записывать их изменения через ``commit -m "Название сохранения"``, сохраняя их в ``log``.

### Что такое репозиторий и инструкция по созданию локальных репозиториев.

### Базовая работа с локальным репозиторием



## Ветки. Локальная работа с ветками в git.

Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветки имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:
* Уже рабочая, стабильная версия кода сохраняется.
* Различные новые функции могут разрабатываться параллельно разными программистами.
* Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
* В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.
Команды для работы с ветками:
* git branch - просмотр существующих веток в репозитории
* git branch name_branch - создание новой ветки в репозитории. можно создавать ветку в ветке.
* git checkout -b name_branch - создание новой ветки и автоматический переход в неё
* git checkout name_branch - переход в ветку name_branch
* git branch -d - удаление "слитой" ветки
* git branch -D - удаление любой ветки
* git log --graph - отображение коммитов в виде дерева веток
* git merge name_branch - слияние текущей ветки и ветки name_branch. При различном содержании могут возникать конфликты, которые git может разрешить самостоятельно, но может понадобиться участие пользователя для выбора источника вносимых изменений

### Что такое ветки и для чего они нужны при работе с системой контроля версий.
- Ветки позволяют командам разработчиков без труда вести совместную работу с одной централизованной базой кода.
- Когда разработчик создает ветку, система контроля версий создает копию базы кода, актуальную на текущий момент времени. Изменения ветки не влияют на работу других разработчиков в команде.

Ветки позволяют командам разработчиков без труда вести совместную работу с одной централизованной базой кода. Когда разработчик создает ветку, система контроля версий создает копию базы кода, актуальную на текущий момент времени. Изменения ветки не влияют на работу других разработчиков в команде. Это, конечно же, хорошо, потому что разработка функциональных возможностей сопряжена с постоянными изменениями, и если бы вся работа велась в главной ветке, процесс разработки погрузился бы в хаос. Но ветки не должны существовать в полной изоляции. Разработчики могут без труда запрашивать изменения у других разработчиков, чтобы вместе работать над функциональностью и не допускать слишком сильного отклонения их собственной ветки от главной.

### Базовая работа с ветками в git.

## Работа с удаленными репозиториями.

### Что такое удаленный репозиторий и для чего он нужен

### Базовая работа с удаленными репозиториями GitHub

## Совместная работа над проектом (fork, pull request)

### Как строится и для чего нужна совместная работа в системах контроля версий

### Инструкция по созданию pull request

1. Форкните проект.
2. Склонируйте репозиторий.
3. Создайте ветку для своей работы.
4. Сделайте необходимые изменения в файлах — коде, документации, тестах. Закоммитьте их в только что созданную ветку.
5. Убедитесь, что проект работает после ваших изменений.
6. Сделайте Pull Request.
7. Когда все довольны, Pull Request принимают — с этого момента ваши изменения попали в исходный репозиторий (upstream) и являются частью проекта.
Работа над задачей закончена!

Теперь рассмотрим каждый этап подробнее.

### Форкаем проект
Вы не можете отправлять коммиты (git push) напрямую в исходный репозиторий. По желанию хозяин проекта может это разрешить, но обычно доступ на запись есть только у людей, поддерживающих проект, а все остальные работают через Pull Request’ы («запросы на вливание изменений»; о них — ниже).

Поэтому мы форкаем проект — это создаст копию репозитория в вашем аккаунте. При этом у вас появится доступ на запись в вашу копию.
![fork](https://rustycrate.ru/assets/contributing/fork-b4128ff517adce95b1d5ebfd30c1cf455bb2abd236543fddf1611d4d3687b159.png)

Через мгновение вы будете перенаправлены на страницу вашего форка.

### Клонируем репозиторий
Затем нужно [склонировать репозиторий](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-Git-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F#%D0%9A%D0%BB%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B5%D0%B3%D0%BE-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F) на вашу локальную машину. Для этого нам нужен URL репозитория. Нажав на кнопку справа, вы скопируете его в буфер обмена. Обратите внимание на выбранный слева протокол. Если вы не настраивали SSH для GitHub, там должно быть указано **HTTPS**.

![Клонируем](https://rustycrate.ru/assets/contributing/clone-810ee60d0b9ff4ea509d28cf3e62d6f81d7e308dac7c15ddf45a203c339f2973.png)
Затем выполняем команду в терминале (или командной строке Windows):

**git clone <вставляем_URL>**

Репозиторий склонируется в под-директорию текущей директории. Например, если репозиторий называется **foobar**, у вас появится каталог **foobar**.

### Создаём ветку
[Ветка](https://git-scm.com/book/ru/v2) по умолчанию — **master**. Чтобы изменениями было проще управлять и они не смешивались друг с другом, создадим отдельную ветку, где и будем работать. При этом ветку стоит назвать так, чтобы имя говорило о её назначении.

Например, мы хотим исправить ошибку в реализации протокола **PROTOBAZ**, так что наша ветка будет называться **fix-protobaz**.

Теперь заходим в наш склонированный репозиторий и [создаём ветку](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F):

1. cd foobar
2. git checkout -b fix-protobaz

Вторая команда создаст ветку и перейдёт на неё (сделает checkout).

Если после этого выполнить **git status**, он покажет

1. On branch fix-protobaz
2. nothing to commit, working directory clean

Эту команду стоит запомнить — когда не понимаете, в каком состоянии репозиторий, просто выполните её. Чаще всего в её выводе git покажет другие команды, которые делают то, что вы (скорее всего) и хотите сделать.

### Делаем изменения
Теперь приступаем к работе. Редактируем код, обновляем документацию, чиним тесты, дополняем README.

Эти изменения мы коммитим в нашу ветку. Как это сделать — ниже.

При этом старайтесь делать коммиты часто, а сами коммиты — небольшими по объёму. Каждый коммит должен делать ровно одну вещь, и при этом поддерживать работоспособность проекта. Стремиться нужно к тому, чтобы в будущем можно было перейти на любой коммит и получить рабочий проект.

Если у вас сразу не получается придерживаться такой дисциплины, или изменения затрагивают весь проект «насквозь», допустимо ломать проект и постепенно чинить его в следующих коммитах.

Если вы уже достаточно разбираетесь в Git, такие не-атомарные изменения потом нужно объединить в один коммит с помощью [interactive rebase](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8#%D0%98%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D1%85-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2) и [squash](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8#%D0%A3%D0%BF%D0%BB%D0%BE%D1%82%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2).

Итак, после редактирования файлов мы имеем следующую ситуацию (это вывод **git status**).  
В выводе есть все необходимые вам команды:

* **git add *file...*** добавляет файл в содержимое коммита, который вы собираетесь записать
* **git checkout -- *file...*** откатывает ваши изменения файла

Поэтому делаем **git add src/protobaz.rs**, а затем **git commit**. Откроется редактор, в котором нужно ввести сообщение коммита.

Сообщение коммита — это описание того, что вы сделали. Его читают другие участники проекта и рецензент. Поэтому оно должно быть осмысленным и читаемым.

Формат сообщения о коммите таков:

1. Краткое описание коммита (не более 50 символов)
2. Подробное описание коммита - зачем он сделан, почему нельзя сделать по-другому,
источники информации.
3. Служебная информация - теги, ссылки на задачи, какие задачи коммит закрывает.

Например,

1. Исправляем длину буфера в реализации PROTOBAZ
2. Неверное вычисление длины приводило к отсечению части сообщения в ситуации,
когда пользователь использует foobar-1.3.4.
3. Смотри http://foobar.org/bugs?id=1234
4. Fix #123

Из всех частей сообщения, только первая является обязательной.

Она должна иметь вид **Глагол в настоящем времени, первом лице, множественном числе** и **объект изменения**. Говорим о том, что мы делаем в этом коммите: [мы] исправляем ошибку, [мы] добавляем возможность, [мы] обновляем документацию.

Последняя строка — это команда GitHub. Когда коммит с такой командой попадает в **master**, GitHub автоматически закроет указанную задачу. Можно использовать разные формы этой команды: **Fix #123**, **fixes #123**, **close #123** и другие. Это экономит время на поддержку проекта.

**git log --oneline** выводит историю в формате «1 коммит — 1 строка на экране». При этом он использует в качестве описания коммита первую строку — краткое описание. Поэтому оно обязательно должно быть отделено пустой строкой от остального описания — иначе однострочный вывод разъедется.

Язык сообщения о коммите должен соответствовать принятому языку проекта. Поскольку наши проекты нацелены на русскоязычную аудиторию и разработчики говорят по-русски, сообщения коммитов также должны быть на русском.

Когда вы ввели сообщение коммита в редакторе, сохранили файл и закрыли его, можно выполнить **git log** и [убедиться](https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2), что коммит записан в историю.

### Проверяем изменения
Когда вы сделали правки, стоит их проверить — если только это не что-то абсолютно тривиальное.

Для этого нужно собрать проект и запустить тесты, если они есть. В любом случае стоит проверить работу кода, который вы написали или изменили, запустив программу или вызвав библиотеку.

Если проект — это статически генерируемый сайт, то сгенерируйте его локально и убедитесь, что ничего не отвалилось и вёрстка не разъехалась. Если книга — то же самое. Смотрите по крайней мере на те места, которые вы правили.

### Создаём Pull Request
Когда работа и проверка закончены, пора создавать Pull Request. Pull Request — это запрос на вливание изменений из вашей ветки в основную ветку исходного репозитория. Таким образом они попадут к хозяевам проекта.

Чтобы создать Pull Request, зайдём на страницу вашего форка. Справа от выпадающего меню с выбором ветки есть кнопка «New pull request».

![Создаём PR](https://rustycrate.ru/assets/contributing/new-pr-550a1c919b0442e2f02f759ed2a73c17b27f8ba57be4efbf058e0f81fce27b42.png)

Нажимаем её.

Вы попадаете в окно сравнения веток.

![PR](https://rustycrate.ru/assets/contributing/pr-e71ca01a91a9e1d66496130ee3ceb0e50acb109be033375e10eee659726e7e3c.png)

Вот элементы этого окна, по порядку:

1. Базовый репозиторий, в который будет создаваться PR. Это должен быть репозиторий, от которого вы делали форк. Если вы форкнули проект **ruRust/rustycrate.ru**, а ваше имя пользователя GitHub — **user**, то у вас будет проект **user/rustycrate.ru**.
2. Базовая ветка в этом репозитории, обычно **master**.
3. Репозиторий, откуда должны вливаться изменения. Здесь должен быть выбран репозиторий в вашем аккаунте — **user/rustycrate.ru**.
4. Ветка, откуда будут вливаться изменения. Это должна быть ветка, которую мы создали в разделе «Создаём ветку».  

Дальше просмотрите изменения — то ли это, что вы делали? Если да, то нажимайте кнопку «Create pull request». В моём примере её нет, т. к. ветки в форке и в оригинале находятся в одинаковом состоянии. В вашем же случае внизу будет список коммитов, которые попадут в исходный репозиторий, и, на других вкладках — сами изменения и комментарии к изменениям.

После нажатия кнопки появится окно ввода сообщения Pull Request.

![Сообщение PR](https://rustycrate.ru/assets/contributing/pr-message-bf4ba4d422facf8cc6954f90dc2bdcd34b1b9b5b8b564ba963720e7ff96ef91a.png)

Сообщение PR — это описание того, что сделано и зачем. В отличие от сообщения коммита, здесь уже нужно писать высокоуровневое описание того, какие изменения сделаны. В части «зачем», а также по формату самого сообщения — стоит придерживаться тех же правил, что и в случае с коммитами. Короткий заголовок (Title), в Comment — описание, а затем служебная информация (**Fix #100500**). Если вы писали команды закрытия задач в коммитах, здесь можно их не дублировать. Если нет — напишите здесь.

Затем нажимаем «Create pull request». Он создаётся, о нём приходит уведомление людям, поддерживающим проект, и он становится виден в исходном репозитории на вкладке «Pull requests». С этого момента начинается рецензирование изменений (code review).

Подсказка: если сразу после того, как вы отправили ветку в свой репозиторий (**git push origin**) зайти на страницу репозитория, там будет предложение создать Pull Request на вливание недавно отправленной ветки в master. Сделать это можно как в вашем форке, так и в исходном репозитории. Это будет отдельная кнопка вверху, и при её нажатии в качестве ветки для слияния будет указана та, куда вы делали **git push**.

### Завершение работы
После вливания PR нужно прибраться в репозитории. Если ваши изменения самодостаточны и после PR не требуется продолжать работу дальше, стоит удалить ветку. Как вы помните, мы создали её раньше, чтобы удобнее управлять изменениями.

Но сначала лучше обновить вашу локальную master-ветку — тогда **git** убедится, что ваша ветка уже влита в **master**, и не будет предупреждать, что вы можете потерять свои изменения.

Итак, обновляем нашу локальную рабочую копию. Для этого добавим ещё один **remote** — так называется удалённый репозиторий. Сейчас он у вас только один — **origin**, и он указывает на ваш форк. Добавим **remote** с именем **upstream**, который будет указывать на исходный репозиторий:

1. git remote add upstream https://github.com/ruRust/rustycrate.ru.git

URL в конце — это URL того репозитория, который вы форкнули. (На всякий случай — он написан в небольшом поле справа от переключателя «HTTPS-SSH», правее зелёной кнопки «New pull request».)

Добавив его, можно обновить наш локальный **master**:

1. git checkout master
2. git pull --rebase upstream/master

А теперь можно удалить нашу ветку fix-protobaz локально:

1. git branch -d fix-protobaz

и на сервере:

1. git push --delete origin fix-protobaz

Теперь у нас чистый, обновлённый репозиторий. Можно начинать работу над новым PR.

## Книги и полезные ссылки по изучению git.

## Альтернативные системы контроля версий.
